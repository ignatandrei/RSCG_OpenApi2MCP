using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using System.Threading.Tasks;
using System.IO;

namespace RSCG_MCP2File;

[Generator]
public class MCP2File : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context
           .RegisterPostInitializationOutput(i =>
           {
               i.AddEmbeddedAttributeDefinition();
               i.AddSource("MCPExportToFile.g.cs", @"
                namespace MCP2File
                {
                    [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
                    [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
                    internal class AddMCPExportToFile: global::System.Attribute {} 
                }");
               i.AddSource("ResultWriteToFile.g.cs", @"
                namespace MCP2File
                {
                    [global::Microsoft.CodeAnalysis.EmbeddedAttribute]                    
                    public class ResultWriteToFile
                    {
                        public bool  Success { get; set; }
                        public string? ErrorMessage { get; set; }
                        public static ResultWriteToFile FromSuccess() => new ResultWriteToFile { Success = true};
                        public static ResultWriteToFile FromError(string errorMessage) => new ResultWriteToFile { Success = false, ErrorMessage = errorMessage };
                    }
                }");
           });

        var nr = 0;
        var mcpClasses = context.SyntaxProvider.ForAttributeWithMetadataName(
            "MCP2File.AddMCPExportToFile",
            static (node, _) => node is ClassDeclarationSyntax,
            static (context, _) =>
            {
                INamedTypeSymbol? classSymbol = null;
                var classDeclaration = context.TargetNode as ClassDeclarationSyntax;
                if (classDeclaration is null)
                    return classSymbol;

                classSymbol = context.TargetSymbol as INamedTypeSymbol;
                return classSymbol;
            })
             .Where(static m => m is not null)
            .Select(static (m, _) => m!)
            .Collect()
            ;
        nr++;

        context.RegisterSourceOutput(mcpClasses, (ctx, clsArr) =>
        {
            if (clsArr.Length == 0)
                return;

            foreach (var cls in clsArr) { 

                var res = GenerateFromClass(cls);
            if (res != null)
            {
                ctx.AddSource($"{cls.Name}_ExportToFile.g.cs", res);

            }
        }

        });
    }

    private static string? GenerateFromClass(INamedTypeSymbol cls)
    {
        var methods = cls
            .GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m =>
                m.GetAttributes().Any(a => a.AttributeClass != null && a.AttributeClass.ToDisplayString().Contains("McpServerTool")) &&
                m.MethodKind == MethodKind.Ordinary &&
                !IsVoidOrTask(m.ReturnType))
            .ToArray();

        if (methods.Length == 0)
            return null;

        var sb = new StringBuilder();
        sb.AppendLine($"// Auto-generated by MCP2File");
        sb.AppendLine($"namespace {cls.ContainingNamespace.ToDisplayString()}");
        sb.AppendLine("{");
        sb.AppendLine($"    public partial class {cls.Name}");
        sb.AppendLine("    {");

        foreach (var method in methods)
        {
            GenerateExportToFileMethod(sb, method);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    static bool IsVoidOrTask(ITypeSymbol returnType)
    {
        return returnType.SpecialType == SpecialType.System_Void ||
               returnType.ToDisplayString() == "System.Threading.Tasks.Task";
    }
    private static void GenerateExportToFileMethod(StringBuilder sb, IMethodSymbol method)
    {
        var returnType = method.ReturnType.ToDisplayString();
        var methodName = method.Name;
        var parameters = method.Parameters
            .Select(p => $"{p.Type.ToDisplayString()} {p.Name}")
            .ToList();
        parameters.Add("[global::System.ComponentModel.Description(\"please use full file path. Do NOT use relative path \")]string exportToFile");
        var paramNames = method.Parameters.Select(p => p.Name).ToList();
        var callParams = string.Join(", ", paramNames);
        var isAsync = method.ReturnType.ToDisplayString().StartsWith("System.Threading.Tasks.Task<");
        var resultType = isAsync ? method.ReturnType is INamedTypeSymbol nts && nts.TypeArguments.Length == 1 ? nts.TypeArguments[0].ToDisplayString() : "object" : returnType;
        var awaitCall = isAsync ? "await " : "";
        var origCall = isAsync ? $"({resultType})await {methodName}({callParams})" : $"{methodName}({callParams})";
        var getResult = isAsync ? $"dynamic result = await {methodName}({callParams});" : $"dynamic result = {methodName}({callParams});";
        sb.AppendLine("         [global::ModelContextProtocol.Server.McpServerTool]");
        sb.AppendLine($"        [global::System.ComponentModel.Description(\"calls the {methodName} and saves the result to a file . Investigate Success parameter from result and, if false, see the ErrorMessage \")]");
        sb.AppendLine($"        public async Task<MCP2File.ResultWriteToFile> {methodName}ExportToFile({string.Join(", ", parameters)})");
        sb.AppendLine("        {");
        
        sb.AppendLine("        try{");
        sb.AppendLine($"            {getResult}");
        sb.AppendLine("            if (result is byte[] bytes)");
        sb.AppendLine("            {");
        sb.AppendLine("                await File.WriteAllBytesAsync(exportToFile, bytes);");
        sb.AppendLine("            }");
        sb.AppendLine("            else if (result is string str)");
        sb.AppendLine("            {");
        sb.AppendLine("                await File.WriteAllTextAsync(exportToFile, str);");
        sb.AppendLine("            }");
        sb.AppendLine("            else");
        sb.AppendLine("            {");
        sb.AppendLine("                await File.WriteAllTextAsync(exportToFile, result?.ToString() ?? string.Empty);");
        sb.AppendLine("            }");
        sb.AppendLine("            return MCP2File.ResultWriteToFile.FromSuccess();");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine("             return MCP2File.ResultWriteToFile.FromError(ex.Message);");
        sb.AppendLine("            ");
        sb.AppendLine("        }");
        sb.AppendLine("        }");
        sb.AppendLine();
    }
}
